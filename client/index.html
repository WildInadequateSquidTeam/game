<!DOCTYPE html>

<html>

	<head>
	
		<meta http-equiv = "Content-Type" content = "text/html; charset=ISO-8859-1">
	
		<title>Game</title>
		
		<link rel = "stylesheet" href = "style/main.css">
	
	</head>
	
	
	
	<body>
	
		<h1>Game</h1>
		<div id = "graphicsContainer">
			<div    id = "backgroundsContainer"></div>

			<canvas id = "main" width = "640" height = "480">Sorry, your browser doesn't support HTML5</canvas>
			
			<div    id = "shadows"></div>
			<canvas id = "stencil" width = "640" height = "480"></canvas>
			<div    id = "foregroundsContainer"></div>
			<div    id = "debug"></div>
			<div    id = "loading"><div>Loading, please wait...</div></div>
		</div>
		<br>
		© 2012, DNA Team
		<br><button onclick = "JavaScript:connect();">Connect</button>
		
		
		<!--<script src = "js/importBox2DJS.js"></script>-->
		<!-- Import Box2D JS files --___-- -->
			<script src="lib/prototype-1.6.0.2.js"></script>
			<script src='js/box2d/common/b2Settings.js'></script>
			<script src='js/box2d/common/math/b2Vec2.js'></script>
			<script src='js/box2d/common/math/b2Mat22.js'></script>
			<script src='js/box2d/common/math/b2Math.js'></script>
			<script src='js/box2d/collision/b2AABB.js'></script>
			<script src='js/box2d/collision/b2Bound.js'></script>
			<script src='js/box2d/collision/b2BoundValues.js'></script>
			<script src='js/box2d/collision/b2Pair.js'></script>
			<script src='js/box2d/collision/b2PairCallback.js'></script>
			<script src='js/box2d/collision/b2BufferedPair.js'></script>
			<script src='js/box2d/collision/b2PairManager.js'></script>
			<script src='js/box2d/collision/b2BroadPhase.js'></script>
			<script src='js/box2d/collision/b2Collision.js'></script>
			<script src='js/box2d/collision/Features.js'></script>
			<script src='js/box2d/collision/b2ContactID.js'></script>
			<script src='js/box2d/collision/b2ContactPoint.js'></script>
			<script src='js/box2d/collision/b2Distance.js'></script>
			<script src='js/box2d/collision/b2Manifold.js'></script>
			<script src='js/box2d/collision/b2OBB.js'></script>
			<script src='js/box2d/collision/b2Proxy.js'></script>
			<script src='js/box2d/collision/ClipVertex.js'></script>
			<script src='js/box2d/collision/shapes/b2Shape.js'></script>
			<script src='js/box2d/collision/shapes/b2ShapeDef.js'></script>
			<script src='js/box2d/collision/shapes/b2BoxDef.js'></script>
			<script src='js/box2d/collision/shapes/b2CircleDef.js'></script>
			<script src='js/box2d/collision/shapes/b2CircleShape.js'></script>
			<script src='js/box2d/collision/shapes/b2MassData.js'></script>
			<script src='js/box2d/collision/shapes/b2PolyDef.js'></script>
			<script src='js/box2d/collision/shapes/b2PolyShape.js'></script>
			<script src='js/box2d/dynamics/b2Body.js'></script>
			<script src='js/box2d/dynamics/b2BodyDef.js'></script>
			<script src='js/box2d/dynamics/b2CollisionFilter.js'></script>
			<script src='js/box2d/dynamics/b2Island.js'></script>
			<script src='js/box2d/dynamics/b2TimeStep.js'></script>
			<script src='js/box2d/dynamics/contacts/b2ContactNode.js'></script>
			<script src='js/box2d/dynamics/contacts/b2Contact.js'></script>
			<script src='js/box2d/dynamics/contacts/b2ContactConstraint.js'></script>
			<script src='js/box2d/dynamics/contacts/b2ContactConstraintPoint.js'></script>
			<script src='js/box2d/dynamics/contacts/b2ContactRegister.js'></script>
			<script src='js/box2d/dynamics/contacts/b2ContactSolver.js'></script>
			<script src='js/box2d/dynamics/contacts/b2CircleContact.js'></script>
			<script src='js/box2d/dynamics/contacts/b2Conservative.js'></script>
			<script src='js/box2d/dynamics/contacts/b2NullContact.js'></script>
			<script src='js/box2d/dynamics/contacts/b2PolyAndCircleContact.js'></script>
			<script src='js/box2d/dynamics/contacts/b2PolyContact.js'></script>
			<script src='js/box2d/dynamics/b2ContactManager.js'></script>
			<script src='js/box2d/dynamics/b2World.js'></script>
			<script src='js/box2d/dynamics/b2WorldListener.js'></script>
			<script src='js/box2d/dynamics/joints/b2JointNode.js'></script>
			<script src='js/box2d/dynamics/joints/b2Joint.js'></script>
			<script src='js/box2d/dynamics/joints/b2JointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2DistanceJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2DistanceJointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2Jacobian.js'></script>
			<script src='js/box2d/dynamics/joints/b2GearJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2GearJointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2MouseJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2MouseJointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2PrismaticJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2PrismaticJointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2PulleyJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2PulleyJointDef.js'></script>
			<script src='js/box2d/dynamics/joints/b2RevoluteJoint.js'></script>
			<script src='js/box2d/dynamics/joints/b2RevoluteJointDef.js'></script>
		<!----------------------------------->
		
		<script src = "js/blur.js"></script>
		<script src = "js/tools.js"></script>
		<script src = "js/logger.js"></script>
		<script src = "js/shadows.js"></script>
		<!--<script src = "js/controls.js"></script>-->
		<script src = "js/phys.js"></script>
		<script src = "js/socket.io.js"></script>
		<script src = "js/sprite.js"></script>
	
	
		<script>
		
			// Some constants
			
			var FPS = 60;
			
			// Scale factor. 96 pixels is ~1.9m
			var SCALE = 96 / 1.9;
			
			// Temp constants
			var PLAYER_SIZE = 0.5;
			var BALL_SPEED = 0.5;
			
			// Shadows
			var SHADOWS_DOWNSAMPLING = 8;
			var SHADOWS_RESERVE = 1.5;
			var SHADOWS_FADING_SPEED = 1;
			var SHADOWS_LIGHT = 2;
			var SHADOWS_BLUR = 0.5;
			var SHADOWS_AMBIENT = 0.1;
			var SHADOWS_FIX = 1;
			
			// Box2d
			var GRAVITY = 9.8;
			var BOX2D_ITERATION = 20;
			
			// Key constants
			var MOUSE_LMB   = 1;
			var MOUSE_RMB   = 2;
			var MOUSE_MMB   = 4;
			var KEY_LEFT    = 1;
			var KEY_RIGHT   = 2;
			var KEY_UP      = 4;
			var KEY_DOWN    = 8;
			var KEY_ACTION1 = 16;
			var KEY_ACTION2 = 32;
			var KEY_ACTION3 = 64;
			var KEY_ACTION4 = 128;
			
			
			// Setup tools
			
			var log = new Logger("debug");
			//log.fix(function() { return controls.mouse.x; });
			
			var imagesLoader = new ImagesLoader();
		
		
			// Load data
			
			var background = new Image();
			background.src = "./media/gfx/background.jpg";
			imagesLoader.add(background);
			var zombie = new Image();
			zombie.src = "media/gfx/zombie.png";
			imagesLoader.add(zombie);
			//var s = new Sprite("media/gfx/sprite01.png", 48, 48, 4);
			//var s = new Sprite("media/gfx/danceninja.png", 48, 48, 4);
			var s = new Sprite("media/gfx/chick.png", 48, 48, 8);
			imagesLoader.add(s.image);
			
			var cursor = new Image();
			cursor.src = "media/gfx/cursor.png";
			imagesLoader.add(cursor);
			
			var dirt = new Image();
			dirt.src = "media/gfx/dirt.png";
			imagesLoader.add(dirt);
			
			
			// Init graphics
			
			var ctx  = document.getElementById("main").getContext("2d");
			ctx.lineWidth = 1 / SCALE;
			ctx.webkitImageSmoothingEnabled = false;
			var width  = ctx.canvas.width;
			var height = ctx.canvas.height;
			var shadows = new Shadows("shadows", width, height, SHADOWS_DOWNSAMPLING, SHADOWS_RESERVE);
			shadows.fadingSpeed = SHADOWS_FADING_SPEED;
			shadows.setAmbientLight(SHADOWS_AMBIENT);
			var backgrounds = new BackgroundsManager();
			
			var stencil = document.getElementById("stencil").getContext("2d");
			stencil.canvas.style.opacity = 0.5;
			
			// Init network
			
			var socket;
			
			function connect(ip) {
			
				if (ip == undefined) {
					if (localStorage.ip != undefined) {
						ip = localStorage.ip
					} else {
						ip = "http://91.232.159.8:1337";
					}						
				} else {
					localStorage.ip = ip;
				}
				
				log.add("Connecting to " + ip);
				
				try {
				
					socket = io.connect(ip);
					socket.on("connecting",       function() { log.add("socket: Connecting...");       });
					socket.on("connect_failed",   function() { log.add("socket: Connection failed");   });
					socket.on("reconnecting",     function() { log.add("socket: Reconnecting...");     });
					socket.on("reconnect_failed", function() { log.add("socket: Reconnection failed"); });
					socket.on("reconnect",        function() { log.add("socket: Reconnected");         });
					socket.on("disconnect",       function() { log.add("socket: Connection lost");	   });
					socket.on("error",            function() { log.add("socket: Error");               });
					
					socket.on("message", function(data) {
						log.add("socket: Message: " + JSON.stringify(data));
					});
					
					socket.on("connect", function() {
						log.add("socket: Connected");
						socket.emit("name", localStorage.nickname == undefined ?
							"Guest" :
							localStorage.nickname
						);
						setInterval(function() {
							if (socket) {
								socket.emit("mouse", {
									x: camera.position.x + (controls.mouse.x - width  / 2) / SCALE,
									y: camera.position.y + (controls.mouse.y - height / 2) / SCALE,
									btnState: controls.mouse.btnState
								});
							}
						}, 1000 / FPS);
					});
					
					socket.on("initState", function(data) {
					
						//log.add("socket: initstate");// + JSON.stringify(data));
					
						// FIXME: potential leakout problems						
						
						players    = [];
						players.id = [];
						for (var i = 0; i < data.players.length; i++) {
							var p = data.players[i];
							players.id.push(p.id);
							players[p.id] = new Player(
								p.position.x, p.position.y,
								p.nickname
							);
						}
						player = players[data.yourId];
						
						bodies     = [];
						bodies.id  = [];
						for (var i = 0; i < data.bodies.length; i++) {
							var b = data.bodies[i];
							bodies.id.push(b.id);
							bodies[b.id] = new Body(
								b.id,
								b.position.x, b.position.y,
								b.angle, b.isCircle, b.data
							);
						}
						
					});
					
					socket.on("playerJoin", function(data) {
						//log.add("socket: new player");// + JSON.stringify(data));
						log.add("Player \"" + data.nickname + "\" joined the server");// + JSON.stringify(data));
						players.id.push(data.id);
						players[data.id] = new Player(
							data.position.x, data.position.y,
							data.nickname
						);
					});
					
					socket.on("playerLeft", function(data) {
						var id = data.id;
						//log.add("socket: player left " + id);
						log.add("Player \"" + players[id].nickname + "\" left the server");
						for (var i = 0; i < players.id.length; i++) {
							if (players.id[i] == id) {
								players.id.splice(i, 1);
								break;
							}
						}
						if (player == players[id]) {
							player = null;
						}
						delete players[id];
					});
					
					socket.on("bodyCreate", function(data) {
						log.add("socket: body create");
						bodies.id.push(data.id);
						bodies[data.id] = new Body(data.id, data.position.x, data.position.y, data.angle, data.isCircle, data.data);
					});
					
					socket.on("bodyDestroy", function(data) {
						log.add("socket: body destroy: " + data.id);
						var id = data.id;
						for (var i = 0; i < bodies.id.length; i++) {
							if (bodies.id[i] == id) {
								bodies.id.splice(i, 1);
								break;
							}
						}
						delete bodies[id]; // FIXME: potential problems
					});
					
					socket.on("currentState", function(data) {
						//log.add("socket: current state " + JSON.stringify(data));
						for (var i = 0; i < data.players.length; i++) {
							var id = data.players[i].id;
							players[id].x = data.players[i].position.x;
							players[id].y = data.players[i].position.y;
							players[id].angle = data.players[i].angle;
							if (data.players[i].mouse) {
								players[id].mouse.x = data.players[i].mouse.x;
								players[id].mouse.y = data.players[i].mouse.y;
							}
						}
						for (var i = 0; i < data.bodies.length; i++) {
							var b = data.bodies[i];
							var id = b.id;
							bodies[id].x = b.position.x;
							bodies[id].y = b.position.y;
							bodies[id].angle = b.angle;
						}
					});
					
					socket.on("debug", function(data) {
						log.add("socket: debug");
						debugBodies = [];
						debugBodies.id = [];
						for (var i = 0; i < data.bodies.length; i++) {
							var b = data.bodies[i];
							debugBodies.id.push(i);
							debugBodies[i] = new Body(
								i,
								b.position.x, b.position.y,
								0, true, {radius: 0.5}, "#0f0"
							);
						}
					});
					
					socket.on("runCommand", function(data) {
						//log.add("socket: " + data.nickname + " broadcasts command: " + data.command);
						runCommand(data.command, data.nickname);
					});
					
					socket.on("say", function(data) {
						log.add(data.nickname + ": " + data.message);
					});
					
					socket.on("full", function(data) {
						//log.add("socket: full");
						log.add("Server is full");
					});
					
				} catch(e) {
					log.add("Connecting error " + e.message);
				}
			}
			
			
			
			
			// Game variables
			
			var controls = {
				mouse: {
					x: width  / 2,
					y: height / 2,
					btnState: 0,
					last_x: width  / 2,
					last_y: height / 2
				},
				keyState: 0
			};
			var camera = {
				position: {
					x: 0,
					y: 0,
					fixed_x: 0,
					fixed_y: 0,
					last_x: 0,
					last_y: 0
				}
			};
			
			var bodies;
			var debugBodies;
			function Body(id, x, y, angle, isCircle, data, color) {
			
				if (color == undefined) {
					color = "#F2CA50";
				}
				
				this.color = color;
			
				this.id = id;
				this.x = x;
				this.y = y;
				this.angle = angle;
				this.isCircle = isCircle;
				this.data = data;
				
				this.draw = function(ctx) {
					
					ctx.save();
					
						//ctx.fillStyle   = "#000";
						//ctx.fillStyle   = this.color;
						ctx.fillStyle = dirt.pattern;
						ctx.strokeStyle = "#293033"; // 510E12
						
						// Draw geometry
						ctx.save();
							//ctx.lineWidth = 2.5 / SCALE;
							ctx.lineWidth = 2.5;
							ctx.translate(this.x, this.y);
							ctx.rotate(this.angle);
							ctx.scale(1 / SCALE, 1 / SCALE);
							ctx.beginPath();
								if (this.isCircle) {
									//ctx.arc(0, 0, this.data.radius, 0, Math.DOUBLE_PI);
									ctx.arc(0, 0, this.data.radius * SCALE, 0, Math.DOUBLE_PI);
								} else {
									var v = this.data.vertices;
									ctx.moveTo(v[0].x * SCALE, v[0].y * SCALE);
									for (var i = 1; i < v.length; i++) {
										ctx.lineTo(v[i].x * SCALE, v[i].y * SCALE);
									}
									ctx.closePath();
								}
							ctx.fill();
							ctx.stroke();
							
							// Draw up-vector
							ctx.lineWidth /= 2;
							ctx.beginPath();
								ctx.moveTo(0, 0);
								if (this.isCircle) {
									ctx.lineTo(0, -this.data.radius);
								} else {
									ctx.lineTo(
										this.data.vertices[0].x,
										this.data.vertices[0].y
									);
								}
							ctx.stroke();
						ctx.restore();
						
						// Draw id
						ctx.scale(1 / SCALE, 1 / SCALE);
						ctx.textAlign = "center";
						ctx.textBaseline = "middle";
						ctx.font = "15px DaysRegular";
						//ctx.shadowColor = "#fff";
						ctx.shadowColor = "#293033";
						ctx.fillStyle   = this.color;
						ctx.shadowBlur = 5; 
						ctx.fillText(this.id, this.x * SCALE, this.y * SCALE);
						
					ctx.restore();
				};
				this.castShadows = function(ctx, x, y, scale) {
					var invert = true;
					if (scale == undefined) {
						scale = 100;
					}
					if (this.isCircle) {
						// http://www.kompoblog.ru/?p=23
						var dx = this.x - x;
						var dy = this.y - y;
						var dd = dx * dx + dy * dy;
						
						if (dd <= this.data.radius * this.data.radius) {
						
							/*ctx.beginPath();
								ctx.arc(x, y, dd * scale, 0, 2 * Math.PI);
							ctx.fill();*/
							//ctx.fillRect(0, 0, width, height);
						
						} else {
						
							var cx = x + dx / 2;
							var cy = y + dy / 2;
							var d = Math.sqrt(dd);
							
							var x1 = this.x;
							var y1 = this.y;
							var r1 = this.data.radius;
							var x2 = cx;
							var y2 = cy;
							var r2 = d / 2;
							var r2r2 = dd / 4;
							
							var DD = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
							var D = Math.sqrt(DD);
							var B = (r2r2 - r1 * r1 + DD) / (2 * D);
							var A = D - B;
							var H = Math.sqrt(r2r2 - B*B);
							
							var X = x1 + (x2-x1)/(D/A);
							var Y = y1 + (y2-y1)/(D/A);
							
							var hx1 = X - (Y-y2)*H/B;
							var hy1 = Y + (X-x2)*H/B;
							var hx2 = X + (Y-y2)*H/B;
							var hy2 = Y - (X-x2)*H/B;
							
							var fx1 = hx1 + (hx1 - x) * scale;
							var fy1 = hy1 + (hy1 - y) * scale;
							var fx2 = hx2 + (hx2 - x) * scale;
							var fy2 = hy2 + (hy2 - y) * scale;
							ctx.beginPath();
								ctx.moveTo((x1 - x) * scale, (y1 - y) * scale);
								ctx.lineTo(fx1, fy1);
								ctx.arcTo(x, y, hx2, hy2, r1);
								ctx.lineTo(fx2, fy2);
								ctx.closePath();
							ctx.fill();
						
						}
						
					} else {
					
						// http://www.codenet.ru/progr/cg/lec_1_2.php
						
						ctx.save();
						
							// FIXME: performance can be improved
						
							ctx.translate(this.x, this.y);
							ctx.rotate(this.angle);
					
							var cosA = Math.cos(-this.angle);
							var sinA = Math.sin(-this.angle);
							var tx = (x - this.x) * cosA - (y - this.y) * sinA;
							var ty = (x - this.x) * sinA + (y - this.y) * cosA;						
							
							var v = this.data.vertices;
							
							var x1 = v[v.length - 1].x;
							var y1 = v[v.length - 1].y;
							
							var iStart = 0;
							var iEnd = v.length - 1;
							var flag = false;
							var prevFlag = false;
							var length = 0;
							
							for (var i = 0; i < v.length; i++) {
								var x2 = v[i].x;
								var y2 = v[i].y;
								// http://coderlife.ru/progr/polozhenie-tochki-otnositelno-pryamoj.html
								var r = (x2 - x1) * (ty - y1) - (y2 - y1) * (tx - x1);
								var flag = ((r > 0) ^ invert);
								if (flag) { 
									length++;
								}
								if (flag != prevFlag) {
									if (flag) {
										iStart = ((i - 1) + v.length) % v.length;
									} else {
										iEnd = min(iEnd, i - 1);
									}
								}
								prevFlag = flag;
								x1 = x2;
								y1 = y2;
							}
							if (flag) {
								iEnd = min(iEnd, v.length - 1);
							}
							
							if (length > 0) {
							
								var fx1 = v[iStart].x + (v[iStart].x - tx) * scale;
								var fy1 = v[iStart].y + (v[iStart].y - ty) * scale;
								var fx2 = v[iEnd].x + (v[iEnd].x - tx) * scale;
								var fy2 = v[iEnd].y + (v[iEnd].y - ty) * scale;
								
								ctx.beginPath();
								
									ctx.moveTo(-tx * scale, -ty * scale);
								
									ctx.lineTo(fx1, fy1);
								
									for (var i = 0, j = iStart; i <= length; i++, j = (j + 1) % v.length) {
										ctx.lineTo(v[j].x, v[j].y);
									}
									
									ctx.lineTo(fx2, fy2);
									ctx.closePath();
									
								ctx.fill();
							
							}
						
						ctx.restore();
					
					}
				};
			}
			
			
			var player;
			var players;
			function Player(x, y, nickname) {
				if (x == undefined) {
					x = 0;
					y = 0;
				}
				if (nickname == undefined) {
					nickname = "";
				}
				this.x = x;
				this.y = y;
				this.angle = 0;
				this.last_x = x;
				this.last_y = y;
				this.nickname = nickname;
				
				this.mouse = {x: width / 2, y: height / 2};
				
				this.draw = function(ctx) {
				
					ctx.save();
					
						ctx.lineWidth = 2.5 / SCALE;
						ctx.strokeStyle = "#293033";
						ctx.fillStyle = "#FF5F0B";
						
						ctx.save();
						
							ctx.translate(this.x, this.y);
							ctx.rotate(this.angle);
							
							ctx.beginPath();
								ctx.arc(0, 0, PLAYER_SIZE, 0, Math.DOUBLE_PI);
							ctx.fill();
							ctx.stroke();
							
							ctx.lineWidth /= 2;
							ctx.beginPath();
								ctx.moveTo(0, 0);
								ctx.lineTo(0, -PLAYER_SIZE);
							ctx.stroke();
							
						ctx.restore();
						
						ctx.save();
							ctx.translate(this.mouse.x, this.mouse.y);
							//ctx.translate(this.x, this.y);
							ctx.scale(1 / SCALE, 1 / SCALE);
							//ctx.translate((this.mouse.x - width / 2), (this.mouse.y - height / 2));
							ctx.drawImage(cursor, 0, 0);
						ctx.restore();

						// FIXME: I'm fucking heavy.
						ctx.scale(1 / SCALE, 1 / SCALE);
						ctx.textAlign = "center";
						ctx.font = "15px DaysRegular";
						ctx.fillStyle = "#000";
						ctx.shadowColor = "#fff";
						ctx.shadowBlur = 5;
						ctx.fillText(this.nickname, this.x * SCALE, this.y * SCALE - 30);
						
					ctx.restore();
					
				};
				
			}
			
			
			
			// Special console commands
			
			function nickname(str) {
				if (str != undefined) {
					localStorage.nickname = str;
					if (player) {
						player.nickname = str;
					}
					log.add("Nickname changed to " + localStorage.nickname);
				} else {
					if (localStorage.nickname) {
						log.add("Your current nickname is \"" + localStorage.nickname + "\"");
					} else {
						log.add("You don't have nickname at this moment");
					}
				}
			}
			
			function runCommand(c, author) {
				if (c) {
					
					if (author == undefined) {
						log.add("> " + c);
					} else {
						log.add(author + " > " + c);
					}
					
					var results = c.match(/^\s*(\w+)(?:\s+|$)(.+)?/);
					if (results) {
						var obj = window[results[1]];
						// connect [ip]
						if (results[1].toLowerCase() == "connect") {
							var ip = c.match(/^\s*connect\s*(.+)?\s*$/i);
							connect(results[2]);
						} else
						// say <message>
						if (results[1].toLowerCase() == "say") {
							say(results[2]);
						} else
						// <<function>> [param1], [param2], ... [paramN]
						if (typeof(obj) == "function") {
							obj();
							/*console.log("results[2]: " + results[2]);
							if (results[2]) {
								//var params = results[2].match(/^\s*(?:(.+)\s*,\s*)*(?:.+)/);
								//obj.call(this, params);
							} else {
								obj();
							}*/
						// <<variable>> [value]
						} else {
							log.add(obj);
						}
					} else {
						
						try {
							eval(c + ";");
						} catch(e) {
							log.add("Error: " + e.message);
						}
						
					}
				}
			}
			
			function svRunCommand(str) {
				socket.emit("svRunCommand", str);
			}
			
			function svBroadcastCommand(str) {
				socket.emit("svBroadcastCommand", str);
			}
			
			function say(str) {
				socket.emit("say", str);
			}
			
			function list() {
				socket.emit("listPlayers");
			}
			
			
			// Init physics
			
			var world = new Box2DWorld(-1000, -1000, 1000, 1000, GRAVITY);
		
			var ball = world.createBall(0, 0, PLAYER_SIZE);
			ball.x = 0;
			ball.y = 0;
			ball.last_x = 0;
			ball.last_y = 0;
			world.createBox(0, 2.5, 5, 0.25, true);
			world.createBox(-4.5, 0, PLAYER_SIZE, PLAYER_SIZE, false);
			world.createBox( 4.5, 0, PLAYER_SIZE, PLAYER_SIZE, false);
			
			
			// First-run nickname request
			if (localStorage.nickname == undefined) {
				var n = prompt("Please enter your nickname: ");
				if (n) {
					nickname(n);
				} else {
					log.add("Please use \"nickname(\"MyName\")\" to set up your nickname");
				}
			}
			
			
			// Run loading checker
			var loadingInt = setInterval(function() {
			
				// Check if all images loaded and connection established
				if (imagesLoader.completed() == false) return;
				
				// Remove "loading" label
				clearInterval(loadingInt);
				document.getElementById("loading").className = "loaded";
				setTimeout(function() {
					document.getElementById("loading").style.display = "none";
				}, 1000);
				
				
				
				// === Launch game ===
				
				shadows.ctx.fillRect(0, 0, shadows.width, shadows.height);
				
				// --- Create and draw backgrounds ---
				
					backgrounds.add(1000, 1000, 1);
					backgrounds[0].fillStyle = "#066";
					for (var i = 0, n = backgrounds[0].width; i < n; i += 10) {
						for (var j = i % 20, m = backgrounds[0].height; j < m; j += 20) {
							backgrounds[0].fillRect(i, j, 10, 10);
						}
					}
					//blurContextRGBA(backgrounds[0], 0, 0, backgrounds[0].width, backgrounds[0].height, 1);
					 
					backgrounds.add(1000, 1000, 2);
					backgrounds[1].fillRect(0, 0, backgrounds[1].width, backgrounds[1].height);
					backgrounds[1].fillStyle = "#033";
					for (var i = 0, n = backgrounds[0].width; i < n; i += 20) {
						for (var j = i % 40, m = backgrounds[0].height; j < m; j += 40) {
							backgrounds[1].fillRect(i, j, 20, 20);
						}
					}
					backgrounds[1].drawImage(background, (backgrounds[0].width - background.width) / 2, (backgrounds[0].height - background.height) / 2);
					
				// -----------------------------------
				
				dirt.pattern = ctx.createPattern(dirt, "repeat");
				
				
				var gameInt = setInterval(function() {
				
					ball.x = ball.GetCenterPosition().x;
					ball.y = ball.GetCenterPosition().y;
					
					// Calc camera coords
					if (player) {
						camera.position.x = player.x;// + (controls.mouse.x - width  / 2) / 2 / SCALE;
						camera.position.y = player.y;// + (controls.mouse.y - height / 2) / 2 / SCALE;
					} else {
						camera.position.x = ball.x + (controls.mouse.x - width  / 2) / 2 / SCALE;
						camera.position.y = ball.y + (controls.mouse.y - height / 2) / 2 / SCALE;
					}
				
					// Parallaxing backgrounds
					// FIXME
					backgrounds.updateParallax(camera.position.x * SCALE, camera.position.y * SCALE);
					//backgrounds.updateParallax(camera.position.x, camera.position.y);
					
					stencil.clearRect(0, 0, width, height);
					stencil.save();
					
					ctx.clearRect(0, 0, width, height);
					ctx.save();
					
						ctx.translate(width / 2, height / 2);
						ctx.scale(SCALE, SCALE);
						ctx.translate(-camera.position.x, -camera.position.y);
						
						stencil.translate(width / 2, height / 2);
						stencil.scale(SCALE, SCALE);
						stencil.translate(-camera.position.x, -camera.position.y);
						stencil.fillStyle = "#000";
						
						// Render scene
						
						// Draw zombie. Ololo
						ctx.drawImage(zombie, 0, 0, zombie.width, zombie.height, 0, 0.15, 1.9, 1.9);		
						s.draw(ctx);
						
						if (players) {
							if (debugBodies) {
								for (var i = 0; i < debugBodies.id.length; i++) {
									debugBodies[debugBodies.id[i]].draw(ctx);
								}
							}
							if (bodies) {
								for (var i = 0; i < bodies.id.length; i++) {
									bodies[bodies.id[i]].draw(ctx);
									bodies[bodies.id[i]].castShadows(stencil, player.x, player.y);
								}
							}
							for (var i = 0; i < players.id.length; i++) {
								players[players.id[i]].draw(ctx);
							}
						} else {
							world.draw(ctx);
						}
						
					ctx.restore();
					
					stencil.restore();
					//blurContextRGBA(stencil, 0, 0, width, height, 10);
					
					// Update and render shadows
					shadows.centrify(camera.position.x * SCALE, camera.position.y * SCALE);
					shadows.fade();
					shadows.beginDrawLights();
						shadows.ctx.save();
						
							shadows.ctx.scale(SCALE, SCALE);
							shadows.ctx.translate(-camera.position.x, -camera.position.y);
							
							// Draw light at current sources positions
							shadows.ctx.beginPath();
								if (players) {
									for (var i = 0; i < players.id.length; i++) {
										var p = players[players.id[i]];
										shadows.ctx.arc(p.x, p.y, SHADOWS_LIGHT / 2, 0, Math.DOUBLE_PI);
									};
								} else {
									shadows.ctx.arc(ball.x, ball.y, SHADOWS_LIGHT / 2, 0, Math.DOUBLE_PI);
								}
							shadows.ctx.fill();
							
							// Draw light to previous sources positions
							shadows.ctx.beginPath();
								if (players) {
									for (var i = 0; i < players.id.length; i++) {
										var p = players[players.id[i]];
										shadows.ctx.moveTo(p.x, p.y);
										shadows.ctx.lineTo(p.last_x, p.last_y);
										p.last_x = p.x;
										p.last_y = p.y;
									};
								} else {
									shadows.ctx.moveTo(ball.x, ball.y);
									shadows.ctx.lineTo(
										ball.last_x,
										ball.last_y
									);
									ball.last_x = ball.x;
									ball.last_y = ball.y;
								}
							shadows.ctx.lineWidth = SHADOWS_LIGHT;
							shadows.ctx.stroke();
						shadows.ctx.restore();
						
					shadows.endDrawLights();
					blurContextRGBA(shadows.ctx, 0, 0, shadows.width, shadows.height, (SHADOWS_BLUR * SCALE * shadows.scaleX) | 0);
					
					// Update physics
					world.Step(1.0 / FPS, BOX2D_ITERATION);
					
					// Ball controlls
					if (!players) {
						var vel = ball.GetLinearVelocity();
						if ((controls.keyState & KEY_LEFT ) != 0) {					
							vel.x -= BALL_SPEED;
						}
						if ((controls.keyState & KEY_RIGHT) != 0) {
							vel.x += BALL_SPEED;
						}
						if ((controls.keyState & KEY_UP   ) != 0) {
							vel.y -= BALL_SPEED;
						}
						if ((controls.keyState & KEY_DOWN ) != 0) {
							vel.y += BALL_SPEED;
						}
						if ((controls.keyState & KEY_ACTION1) != 0) {
							vel.x = vel.y = 0;
							// FIXME: this doesn't work
							// ball.SetAngularVelocity(vel);
							ball.SetCenterPosition(new b2Vec2(0, 0), 0);
						}
						if ((controls.keyState & KEY_ACTION2) != 0) {
							vel.x *= 0.5;
							vel.y *= 0.5;
						}
						ball.SetLinearVelocity(vel);
					}
					
					
				}, 1000 / FPS);
				
			}, 250);
			
			
			
			// Hook up handlers
			window.onkeydown = function(e) {

				switch(e.keyCode) {
					
					 // Up
					case 87: case 38:
						controls.keyState |= KEY_UP;
						break;
					
					 // Down
					case 83: case 40:
						controls.keyState |= KEY_DOWN;
						break;
					
					 // Right
					case 68: case 39:
						controls.keyState |= KEY_RIGHT;
						break;
					
					// Left
					case 65: case 37:
						controls.keyState |= KEY_LEFT;
						break;
					
					// Escape
					case 27:
						log.add("Escape");
						break;
					
					// Space
					case 32:
						controls.keyState |= KEY_ACTION1;
						break;
						
					// Left shift
					case 16:
						controls.keyState |= KEY_ACTION2;
						break;
					
					// Enter
					case 13:
						runCommand(prompt("Enter command: "));
						break;
					
					// Tilda
					case 192:
						log.switch();
						break;
						
					default: log.add("Unused key(" + e.keyCode + ") pressed");
				}
				
				if (socket) {
					socket.emit("key", controls.keyState);
				}
				
			};

			window.onkeyup = function(e) {
			
				switch(e.keyCode) {
					case 87: case 38:	// Up
						controls.keyState &= ~KEY_UP;
						break;
					case 83: case 40:	// Down
						controls.keyState &= ~KEY_DOWN;
						break;
					case 68: case 39:	// Right
						controls.keyState &= ~KEY_RIGHT;
						break;
					case 65: case 37:	// Left
						controls.keyState &= ~KEY_LEFT;
						break;
					case 32:			// Space
						controls.keyState &= ~KEY_ACTION1;
						break;
					case 16:            // Shift
						controls.keyState &= ~KEY_ACTION2;
						break;
				}
				
				if (socket) {
					socket.emit("key", controls.keyState);
				}
			};
			
			
			ctx.canvas.parentNode.draggable = true;
			ctx.canvas.parentNode.ondragstart   = function() {  return false; };
			ctx.canvas.parentNode.oncontextmenu = function() {	return false; };
			ctx.canvas.parentNode.onmousedown = function(e) {
				var button = 0;
				switch(e.which) {
					case 1: controls.mouse.btnState |= button = MOUSE_LMB; break;
					case 2: controls.mouse.btnState |= button = MOUSE_MMB; break;
					case 3: controls.mouse.btnState |= button = MOUSE_RMB; break;
				}
				if (socket) {
					socket.emit("mouseDown", {
						x: camera.position.x + (controls.mouse.x - width  / 2) / SCALE,
						y: camera.position.y + (controls.mouse.y - height / 2) / SCALE,
						btnState: controls.mouse.btnState,
						button: button
					});
				}
			};
			ctx.canvas.parentNode.onmouseup = function(e) {
				var button = 0;
				switch(e.which) {
					case 1: controls.mouse.btnState &= ~(button = MOUSE_LMB); break;
					case 2: controls.mouse.btnState &= ~(button = MOUSE_MMB); break;
					case 3: controls.mouse.btnState &= ~(button = MOUSE_RMB); break;
				}
				if (socket) {
					socket.emit("mouseUp", {
						x: camera.position.x + (controls.mouse.x - width  / 2) / SCALE,
						y: camera.position.y + (controls.mouse.y - height / 2) / SCALE,
						btnState: controls.mouse.btnState,
						button: button
					});
				}
			};
			
			ctx.canvas.parentNode.onmousemove = function(e) {
				// FIXME: this won't work in firefox.
				controls.mouse.x = e.offsetX;
				controls.mouse.y = e.offsetY;
			};
			
		</script>
	
	</body>

</html>